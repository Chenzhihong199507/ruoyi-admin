import "./chunk-AT5Z25UJ.js";
import {
  watch
} from "./chunk-BYNCQTQY.js";
import {
  readonly,
  ref,
  toRaw
} from "./chunk-PP6SRANN.js";
import "./chunk-N3MIDBCY.js";
import "./chunk-PR4QN5HX.js";

// ../../node_modules/.pnpm/@tanstack+store@0.5.5/node_modules/@tanstack/store/dist/esm/index.js
var Store = class {
  constructor(initialState, options) {
    this.listeners = /* @__PURE__ */ new Set();
    this._batching = false;
    this._flushing = 0;
    this.subscribe = (listener) => {
      var _a, _b;
      this.listeners.add(listener);
      const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
      return () => {
        this.listeners.delete(listener);
        unsub == null ? void 0 : unsub();
      };
    };
    this.setState = (updater) => {
      var _a, _b, _c;
      const previous = this.state;
      this.state = ((_a = this.options) == null ? void 0 : _a.updateFn) ? this.options.updateFn(previous)(updater) : updater(previous);
      (_c = (_b = this.options) == null ? void 0 : _b.onUpdate) == null ? void 0 : _c.call(_b);
      this._flush();
    };
    this._flush = () => {
      if (this._batching) return;
      const flushId = ++this._flushing;
      this.listeners.forEach((listener) => {
        if (this._flushing !== flushId) return;
        listener();
      });
    };
    this.batch = (cb) => {
      if (this._batching) return cb();
      this._batching = true;
      cb();
      this._batching = false;
      this._flush();
    };
    this.state = initialState;
    this.options = options;
  }
};

// ../../node_modules/.pnpm/@tanstack+vue-store@0.5.5_vue@3.5.11_typescript@5.6.2_/node_modules/@tanstack/vue-store/dist/esm/index.js
function useStore(store, selector = (d) => d) {
  const slice = ref(selector(store.state));
  watch(
    () => store,
    (value, _oldValue, onCleanup) => {
      const unsub = value.subscribe(() => {
        const data = selector(value.state);
        if (shallow(toRaw(slice.value), data)) {
          return;
        }
        slice.value = data;
      });
      onCleanup(() => {
        unsub();
      });
    },
    { immediate: true }
  );
  return readonly(slice);
}
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
export {
  Store,
  shallow,
  useStore
};
//# sourceMappingURL=@tanstack_vue-store.js.map
