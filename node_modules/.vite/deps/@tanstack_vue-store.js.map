{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@tanstack+store@0.5.5/node_modules/@tanstack/store/src/index.ts", "../../../../../node_modules/.pnpm/@tanstack+vue-store@0.5.5_vue@3.5.11_typescript@5.6.2_/node_modules/@tanstack/vue-store/src/index.ts"],
  "sourcesContent": ["export type AnyUpdater = (...args: Array<any>) => any\n\nexport type Listener = () => void\n\nexport interface StoreOptions<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  updateFn?: (previous: TState) => (updater: TUpdater) => TState\n  onSubscribe?: (\n    listener: Listener,\n    store: Store<TState, TUpdater>,\n  ) => () => void\n  onUpdate?: () => void\n}\n\nexport class Store<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  listeners = new Set<Listener>()\n  state: TState\n  options?: StoreOptions<TState, TUpdater>\n  _batching = false\n  _flushing = 0\n\n  constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>) {\n    this.state = initialState\n    this.options = options\n  }\n\n  subscribe = (listener: Listener) => {\n    this.listeners.add(listener)\n    const unsub = this.options?.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n\n  setState = (updater: TUpdater) => {\n    const previous = this.state\n    this.state = this.options?.updateFn\n      ? this.options.updateFn(previous)(updater)\n      : (updater as any)(previous)\n\n    // Always run onUpdate, regardless of batching\n    this.options?.onUpdate?.()\n\n    // Attempt to flush\n    this._flush()\n  }\n\n  _flush = () => {\n    if (this._batching) return\n    const flushId = ++this._flushing\n    this.listeners.forEach((listener) => {\n      if (this._flushing !== flushId) return\n      listener()\n    })\n  }\n\n  batch = (cb: () => void) => {\n    if (this._batching) return cb()\n    this._batching = true\n    cb()\n    this._batching = false\n    this._flush()\n  }\n}\n", "import { readonly, ref, toRaw, watch } from 'vue-demi'\nimport type { AnyUpdater, Store } from '@tanstack/store'\nimport type { Ref } from 'vue-demi'\n\nexport * from '@tanstack/store'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport function useStore<\n  TState,\n  TSelected = NoInfer<TState>,\n  TUpdater extends AnyUpdater = AnyUpdater,\n>(\n  store: Store<TState, TUpdater>,\n  selector: (state: NoInfer<TState>) => TSelected = (d) => d as any,\n): Readonly<Ref<TSelected>> {\n  const slice = ref(selector(store.state)) as Ref<TSelected>\n\n  watch(\n    () => store,\n    (value, _oldValue, onCleanup) => {\n      const unsub = value.subscribe(() => {\n        const data = selector(value.state)\n        if (shallow(toRaw(slice.value), data)) {\n          return\n        }\n        slice.value = data\n      })\n\n      onCleanup(() => {\n        unsub()\n      })\n    },\n    { immediate: true },\n  )\n\n  return readonly(slice) as never\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n"],
  "mappings": ";;;;;;;;;;;;;AAgBO,IAAM,QAAN,MAGL;EAOA,YAAY,cAAsB,SAA0C;AAN5E,SAAA,YAAA,oBAAgB,IAAA;AAGJ,SAAA,YAAA;AACA,SAAA,YAAA;AAOZ,SAAA,YAAY,CAAC,aAAuB;AAf/B,UAAA,IAAA;AAgBE,WAAA,UAAU,IAAI,QAAQ;AAC3B,YAAM,SAAQ,MAAA,KAAA,KAAK,YAAL,OAAA,SAAA,GAAc,gBAAd,OAAA,SAAA,GAAA,KAAA,IAA4B,UAAU,IAAA;AACpD,aAAO,MAAM;AACN,aAAA,UAAU,OAAO,QAAQ;AACtB,iBAAA,OAAA,SAAA,MAAA;MAAA;IACV;AAGF,SAAA,WAAW,CAAC,YAAsB;AAxB7B,UAAA,IAAA,IAAA;AAyBH,YAAM,WAAW,KAAK;AACtB,WAAK,UAAQ,KAAA,KAAK,YAAL,OAAA,SAAA,GAAc,YACvB,KAAK,QAAQ,SAAS,QAAQ,EAAE,OAAO,IACtC,QAAgB,QAAQ;AAG7B,OAAA,MAAA,KAAA,KAAK,YAAL,OAAA,SAAA,GAAc,aAAd,OAAA,SAAA,GAAA,KAAA,EAAA;AAGA,WAAK,OAAO;IAAA;AAGd,SAAA,SAAS,MAAM;AACb,UAAI,KAAK,UAAW;AACd,YAAA,UAAU,EAAE,KAAK;AAClB,WAAA,UAAU,QAAQ,CAAC,aAAa;AAC/B,YAAA,KAAK,cAAc,QAAS;AACvB,iBAAA;MAAA,CACV;IAAA;AAGH,SAAA,QAAQ,CAAC,OAAmB;AACtB,UAAA,KAAK,UAAW,QAAO,GAAA;AAC3B,WAAK,YAAY;AACd,SAAA;AACH,WAAK,YAAY;AACjB,WAAK,OAAO;IAAA;AAxCZ,SAAK,QAAQ;AACb,SAAK,UAAU;EACjB;AAwCF;;;AC7DO,SAAS,SAKd,OACA,WAAkD,CAAC,MAAM,GAC/B;AAC1B,QAAM,QAAQ,IAAI,SAAS,MAAM,KAAK,CAAC;AAEvC;IACE,MAAM;IACN,CAAC,OAAO,WAAW,cAAc;AACzB,YAAA,QAAQ,MAAM,UAAU,MAAM;AAC5B,cAAA,OAAO,SAAS,MAAM,KAAK;AACjC,YAAI,QAAQ,MAAM,MAAM,KAAK,GAAG,IAAI,GAAG;AACrC;QACF;AACA,cAAM,QAAQ;MAAA,CACf;AAED,gBAAU,MAAM;AACR,cAAA;MAAA,CACP;IACH;IACA,EAAE,WAAW,KAAK;EAAA;AAGpB,SAAO,SAAS,KAAK;AACvB;AAEgB,SAAA,QAAW,MAAS,MAAS;AAC3C,MAAI,OAAO,GAAG,MAAM,IAAI,GAAG;AAClB,WAAA;EACT;AAGE,MAAA,OAAO,SAAS,YAChB,SAAS,QACT,OAAO,SAAS,YAChB,SAAS,MACT;AACO,WAAA;EACT;AAEM,QAAA,QAAQ,OAAO,KAAK,IAAI;AAC9B,MAAI,MAAM,WAAW,OAAO,KAAK,IAAI,EAAE,QAAQ;AACtC,WAAA;EACT;AAEA,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AAEnC,QAAA,CAAC,OAAO,UAAU,eAAe,KAAK,MAAM,MAAM,CAAC,CAAW,KAC9D,CAAC,OAAO,GAAG,KAAK,MAAM,CAAC,CAAY,GAAG,KAAK,MAAM,CAAC,CAAY,CAAC,GAC/D;AACO,aAAA;IACT;EACF;AACO,SAAA;AACT;",
  "names": []
}
